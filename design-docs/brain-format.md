# Формат мозга — NEAT-геном и пластичность

Мозг существа — нейросеть с изменяемой топологией (NEAT: NeuroEvolution of Augmenting Topologies).
ДНК мозга кодирует и топологию (какие нейроны и связи), и начальные веса.
В процессе жизни веса могут меняться (Hebbian plasticity).

---

## 1. Общая структура

```typescript
interface BrainGenome {
  nodeGenes: NodeGene[];
  connectionGenes: ConnectionGene[];
  
  // Параметры пластичности (эволюционируют)
  plasticityRate: number;  // 0..0.1, дефолт 0.01. Скорость обучения Hebbian
}
```

---

## 2. Node Genes (нейроны)

```typescript
interface NodeGene {
  id: number;                           // Уникальный ID нейрона
  type: "input" | "hidden" | "output";  // Тип
  activation: ActivationType;           // Функция активации
}

type ActivationType = "sigmoid" | "tanh" | "relu" | "linear" | "step";
```

### Типы нейронов

- **input**: по одному на каждый вход (определяется сенсорами из ДНК). Не имеют функции активации — значение задаётся напрямую.
- **output**: по одному на каждый выход (определяется актуаторами из ДНК). Функция активации — `tanh` по умолчанию.
- **hidden**: промежуточные нейроны. Появляются через мутацию "add node". Функция активации мутирует.

### Маппинг входов/выходов

Порядок нейронов `input` соответствует порядку сенсоров в ДНК:

```
Входы (input nodes):
  [0]    bias (всегда 1.0)
  [1]    random (uniform 0..1)
  [2..5] rayVision ray 0: distance, type_food, type_creature, type_iff
  [6..9] rayVision ray 1: distance, type_food, type_creature, type_iff
  ...
  [N]    touch: touching_food, touching_creature, touching_iff
  [N+3]  energySense: energy_level
  [N+4]  broadcastReceiver ch0: strength, direction
  ...

Выходы (output nodes):
  [0]    move: forward
  [1]    move: turn
  [2]    eat: eat
  [3]    attack: attack (если есть)
  [4]    donate: donate (если есть)
  [5]    broadcast: broadcast (если есть)
```

Точный маппинг зависит от конкретной ДНК существа. Порядок фиксирован при создании
существа и не меняется в течение жизни.

---

## 3. Connection Genes (связи)

```typescript
interface ConnectionGene {
  innovationNumber: number;  // Глобальный уникальный ID мутации (для кроссовера/специации)
  fromNode: number;          // ID исходного нейрона
  toNode: number;            // ID целевого нейрона
  weight: number;            // Вес связи, float (-5..5)
  enabled: boolean;          // Активна ли связь
}
```

### Innovation Number

Каждая новая структурная мутация (add connection, add node) получает глобальный `innovationNumber`.
Если два разных существа создают одинаковую связь (тот же fromNode → toNode), они получают
одинаковый `innovationNumber`. Это нужно для:
- Корректного сравнения геномов при вычислении расстояния (специации)
- Корректного кроссовера (если позже добавим половое размножение)

**Реализация:** глобальный счётчик + кэш `(fromNode, toNode) → innovationNumber` на поколение.

---

## 4. Forward Pass (вычисление сети)

### Алгоритм

1. Записать значения сенсоров в input-нейроны
2. Для каждого нейрона в топологическом порядке (от входов к выходам):
   - Собрать входящие значения: `sum = Σ(weight_i * value_from_i)` для всех enabled connections
   - Применить функцию активации: `value = activation(sum)`
3. Прочитать значения output-нейронов → команды актуаторов

### Топологическая сортировка

Вычисляется один раз при создании существа (или при мутации топологии).
Хранится как массив ID нейронов в порядке вычисления.

### Рекуррентные связи

Связи "назад" (от нейрона с большим depth к нейрону с меньшим) допускаются.
Значение берётся с предыдущего тика (задержка на 1 такт). Это позволяет сети
иметь "память" и циклическую обработку.

### Функции активации

| Название | Формула              | Область значений |
|----------|----------------------|------------------|
| sigmoid  | 1 / (1 + exp(-x))   | (0, 1)           |
| tanh     | tanh(x)              | (-1, 1)          |
| relu     | max(0, x)            | [0, +∞)          |
| linear   | x                    | (-∞, +∞)         |
| step     | x > 0 ? 1 : 0       | {0, 1}           |

---

## 5. Hebbian Plasticity (обучение при жизни)

Веса связей могут меняться в процессе жизни существа (не только при размножении).
Это позволяет существу адаптироваться к текущей среде без эволюции.

### Правило обновления

```
Δw = plasticityRate * pre * post * modulator
w_new = clamp(w + Δw, -5, 5)
```

Где:
- `pre` — значение пре-синаптического нейрона (источник связи)
- `post` — значение пост-синаптического нейрона (цель связи)
- `modulator` — сигнал "награды/штрафа"
- `plasticityRate` — скорость обучения (эволюционирует в ДНК)

### Модулятор

```
modulator = clamp(energyDelta / 10, -1, 1)
```

Где `energyDelta = energy_now - energy_prev` (изменение энергии за тик):
- Съел еду → положительный модулятор → усиление связей, приведших к еде
- Получил урон → отрицательный модулятор → ослабление связей
- Просто потерял метаболизм → слегка отрицательный → медленное затухание неиспользуемых связей

### Частота обновления

Веса обновляются с частотой `brainRate` (вместе с вычислением мозга),
а не каждый sim tick.

### Важное ограничение

Hebbian plasticity меняет RUNTIME-веса существа. При размножении потомок получает
ГЕНОМНЫЕ веса (из connectionGenes), а не runtime-веса родителя.
Ламаркианское наследование (наследование приобретённых весов) можно добавить как опцию позже.

---

## 6. Мутации мозга при размножении

### 6.1 Weight Jitter

- Вероятность: `mutationRate` на каждую связь
- Действие: `weight += gaussian(0, mutationStrength)`
- Результат: clamp(-5, 5)

### 6.2 Add Connection

- Вероятность: `mutationRate * 0.5`
- Действие: выбрать два случайных нейрона (A, B), создать связь A→B
- Условия: связь A→B ещё не существует, A ≠ B
- Вес: случайный uniform(-1, 1)
- Innovation: присваивается из глобального кэша

### 6.3 Add Node

- Вероятность: `mutationRate * 0.3`
- Действие: выбрать случайную enabled связь, разбить её нейроном
  - Старая связь A→B отключается (enabled = false)
  - Создаётся новый hidden нейрон C
  - Создаётся связь A→C с весом 1.0
  - Создаётся связь C→B с весом = старый вес A→B
- Активация нового нейрона: случайная из [sigmoid, tanh, relu]

### 6.4 Toggle Connection

- Вероятность: `mutationRate * 0.1`
- Действие: случайная связь меняет enabled ↔ disabled

### 6.5 Change Activation

- Вероятность: `mutationRate * 0.1`
- Действие: случайный hidden нейрон меняет функцию активации

### 6.6 Plasticity Rate Jitter

- Вероятность: `mutationRate`
- Действие: `plasticityRate += gaussian(0, 0.005)`
- Результат: clamp(0, 0.1)

---

## 7. Обработка структурных мутаций ДНК (добавление/удаление сенсоров/актуаторов)

Когда мутация ДНК добавляет или удаляет сенсор/актуатор, количество входов/выходов
нейросети меняется. Мозг должен адаптироваться:

### При добавлении сенсора

1. Создать новые input-нейроны (по количеству входов нового сенсора)
2. Добавить случайные связи от новых input-нейронов к случайным существующим нейронам
3. Веса новых связей: случайные, малые (uniform(-0.5, 0.5))

### При удалении сенсора

1. Удалить соответствующие input-нейроны
2. Удалить все связи, идущие от удалённых нейронов
3. Hidden нейроны, потерявшие все входящие связи, остаются (могут получить новые при мутации)

### При добавлении актуатора

1. Создать новые output-нейроны
2. Добавить случайные связи от случайных существующих нейронов к новым output-нейронам
3. Веса: случайные, малые

### При удалении актуатора

1. Удалить соответствующие output-нейроны
2. Удалить все связи, идущие к удалённым нейронам

---

## 8. Специация (distance metric)

> Заложена в дизайн, реализация — позже.

Для поддержания разнообразия популяции можно группировать существ по видам.
Расстояние между двумя геномами:

```
distance = c1 * E / N + c2 * D / N + c3 * W_avg
```

Где:
- `E` — количество excess генов (есть у одного, нет у другого, за пределами max innovation)
- `D` — количество disjoint генов (есть у одного, нет у другого, внутри диапазона)
- `N` — длина более длинного генома (нормализация)
- `W_avg` — среднее абсолютное различие весов matching генов
- `c1, c2, c3` — коэффициенты (настраиваемые)

Если `distance < threshold`, два существа относятся к одному виду.
Фитнес внутри вида делится (sharing), чтобы маленькие виды не вымирали.

---

## 9. Начальный мозг

При создании существа (или мира) генерируется минимальный мозг:

1. Input-нейроны: по количеству входов из ДНК
2. Output-нейроны: по количеству выходов из ДНК  
3. Связи: каждый input напрямую к каждому output (fully connected)
4. Веса: случайные uniform(-1, 1)
5. `plasticityRate`: 0.01

Топология будет усложняться через мутации add_node и add_connection.

---

## 10. Оптимизация вычислений

Для 5-10k существ мозг считается `brainRate` раз в секунду (10 Hz = 100k inference/сек).

### Стратегии

1. **TypedArrays**: веса и активации хранить в Float32Array, не в объектах
2. **Предвычисленный topological order**: вычислять один раз, обновлять только при мутации
3. **Batch processing**: группировать существ с одинаковой топологией и считать батчем
4. **Brain tick decimation**: если существо "спит" (не двигается), можно пропускать тики мозга

### Структуры данных для runtime

```typescript
interface BrainRuntime {
  // Предвычисленные структуры
  evalOrder: number[];        // Топологический порядок нейронов
  connections: Float32Array;  // [fromIdx, toIdx, weight, enabled] для каждой связи
  
  // Runtime state
  activations: Float32Array;  // Текущие значения нейронов
  prevActivations: Float32Array;  // Предыдущие значения (для рекуррентных связей)
}
```

---

## 11. Сериализация

Мозг сериализуется как часть ДНК:

```json
{
  "brain": {
    "plasticityRate": 0.01,
    "nodeGenes": [
      { "id": 0, "type": "input", "activation": "linear" },
      { "id": 1, "type": "input", "activation": "linear" },
      { "id": 6, "type": "output", "activation": "tanh" },
      { "id": 7, "type": "hidden", "activation": "sigmoid" }
    ],
    "connectionGenes": [
      { "innovationNumber": 1, "fromNode": 0, "toNode": 6, "weight": 0.5, "enabled": true },
      { "innovationNumber": 2, "fromNode": 1, "toNode": 7, "weight": -0.3, "enabled": true },
      { "innovationNumber": 3, "fromNode": 7, "toNode": 6, "weight": 1.2, "enabled": true }
    ]
  }
}
```

Runtime-веса (изменённые пластичностью) НЕ сохраняются в ДНК, но сохраняются
в snapshot мира (IndexedDB) для восстановления состояния.
