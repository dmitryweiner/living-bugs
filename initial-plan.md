## **План работ (с артефактами и контрольными точками)**

### **Этап A — Каркас репозитория и “скелет симуляции” (2–4 дня)**

**Цель:** запустить один и тот же сим-код в Node и в браузере.

**Сделать**

* Monorepo:

  * `packages/sim-core`

  * `apps/web`

  * `apps/headless`

  * `packages/config-dsl`

* В `sim-core`:

  * `World.step(fixedDt)`

  * PRNG с seed

  * сущности: `Creature`, `Item`

  * простой event-log (для отладки)

**Готово когда**

* headless печатает метрики по тикам

* web показывает мир (хотя бы точки) и тикает тем же `sim-core`.

---

### **Этап B — Физика столкновений под 100k (3–7 дней)**

**Цель:** дешёвые коллизии, которые не убьют FPS.

**Сделать**

* Spatial hash grid:

  * cellSize \~ 2\*maxRadius

  * обновление позиций в сетке

  * запрос соседей

* Коллизии:

  * circle-circle overlap

  * коррекция позиции (раздвижка)

  * опционально ограничение скорости

**Оптимизации**

* разделить “render tick” (rAF) и “sim tick” (фиксированный dt, можно 20–60Hz)

* “мозг” и сенсоры можно считать реже (например 10–20Hz), а движение/коллизии чаще

**Готово когда**

* 10k работает бодро, 50k не падает, 100k — хотя бы в headless терпимо.

---

### **Этап C — DSL конфиг мира (AST) (1–2 недели)**

**Цель:** правила мира через расширяемый конфиг.

**Сделать**

* `config-dsl`:

  * JSON Schema для `WorldConfig` \+ `Expr`

  * `Expr` как AST:

    * литералы, переменные (context vars)

    * арифметика, min/max, clamp

    * if/else

    * доступ к свойствам `creature.energy`, `item.type`, `distance`, etc.

* Реестр операций:

  * `op: "add" | "mul" | "if" | "lt" | ...`

  * возможность добавлять новые op без ломания старых

**JIT (по желанию, но полезно)**

* компилировать Expr в JS-функцию без eval (через ручную генерацию функции/байткода) — можно позже.

**Готово когда**

* ты меняешь формулу “стоимость движения” в JSON — и симуляция меняется без изменения кода `sim-core`.

---

### **Этап D — ДНК v1: модули сенсоров/актуаторов \+ углы (1–2 недели)**

**Цель:** описывать существо ДНК, но без геометрии тела.

**Сделать**

* `DNA`:

  * `groupId` (фиксированная группа)

  * `hasIFF` (распознавание свой/чужой; может мутировать выключаться)

  * сенсоры:

    * `rayVision`: N лучей, fov, maxDist, углы/смещения

    * `touch`: контакт

    * `iff`: если включён — маркировка “свой/чужой”

  * актуаторы (дискретные команды):

    * move: (FWD / TURN\_L / TURN\_R / STOP)

    * attack: (ON/OFF)

    * eat: (ON/OFF или авто при контакте)

    * donate: (ON/OFF \+ amount bucket)

    * broadcast: (ON/OFF \+ signalId)

* Стоимость модулей (в конфиге мира): чтобы эволюция платила за “глаза на затылке”.

**Готово когда**

* два существа с разной ДНК реально ведут себя по-разному и по-разному “стоят” по энергии.

---

### **Этап E — “мозг” v1: минимальный NEAT-совместимый (2–4 недели)**

**Цель:** эволюция топологии и весов, дискретные команды.

**Совет по реализации**  
 Сразу делай ДНК мозга в духе NEAT:

* `nodeGenes`: input/hidden/output (+ type)

* `connectionGenes`: (in, out, weight, enabled, innovation)

* мутации:

  * weight jitter

  * add connection

  * add node (split connection)

  * toggle connection

* совместимость (distance) для специации — можно внедрить не сразу, но закладывай.

**Дискретные команды**

* выходы сети: logits на каждое действие

* выбор действия: argmax или softmax+sample (в headless можно seed-sample).

**Пластичность “в жизни”**

* простое правило Hebb:

  * `w += lr * pre * post * modulator`

* модulator можно связать с “награда/штраф” (прирост энергии за тик, успешная атака и т.д.)

**Готово когда**

* в headless видно, что лучшие генотипы действительно улучшаются по метрике (выживание/энергия/репродукция).

---

### **Этап F — Эволюция: отбор, репликация, метрики, “hall of fame” (1–2 недели)**

**Цель:** прогон поколений и экспорт лучших.

**Сделать**

* Модель поколений (простая):

  * симулируем T секунд

  * считаем фитнес

  * берём top K → клонируем с мутациями до N

* Сохранение headless:

  * `best_genotypes.json` (topN \+ статистика)

* Веб-импорт:

  * загрузка генотипов и “посев” мира ими.

**Готово когда**

* ты можешь “натренировать” популяцию в консоли и потом поиграть с ней в браузере.

---

### **Этап G — Браузерный UX \+ сохранения мира (1–2 недели, параллельно)**

**Цель:** playable песочница.

**Сделать**

* Pixi:

  * камера pan/zoom

  * батч-отрисовка (instanced/particle-like, без спрайтов на 100k)

* Инспектор существа:

  * показывать сенсорные лучи выбранного

  * показывать действия мозга, энергию, ДНК

* Сохранение:

  * IndexedDB snapshot при закрытии/ручной кнопке

  * в снапшоте: world state \+ PRNG seed \+ текущая версия конфигов

**Готово когда**

* можно закрыть вкладку, открыть — мир восстановился.

---

## **Минимальные “контрольные вехи”, чтобы не расползлось**

1. **Milestone 1:** sim-core работает в Node+Web, есть базовые сущности и шаг симуляции.

2. **Milestone 2:** 10k–50k агентов с коллизиями без смерти браузера.

3. **Milestone 3:** DSL формулы реально влияют на мир без правки кода.

4. **Milestone 4:** DNA v1 создаёт разное поведение/стоимость.

5. **Milestone 5:** headless эволюция даёт улучшение метрики и экспорт лучших.

6. **Milestone 6:** web импортирует лучших и сохраняет мир.

